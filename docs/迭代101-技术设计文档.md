# 迭代101 - 回测分析可视化优化 - 技术设计文档

## 1. 概述

本文档详细描述回测分析可视化优化的技术实现方案，包括后端API设计、前端组件设计、数据结构定义等。

---

## 2. 后端设计

### 2.1 数据模型

#### 2.1.1 绩效指标模型
```python
# backend/app/schemas/analytics.py

from pydantic import BaseModel
from typing import List, Dict, Optional
from datetime import datetime

class PerformanceMetrics(BaseModel):
    """绩效指标"""
    initial_capital: float          # 初始资金
    final_assets: float             # 最终资产
    total_return: float             # 总收益率
    annualized_return: float        # 年化收益率
    max_drawdown: float             # 最大回撤
    max_drawdown_duration: int      # 最大回撤持续天数
    sharpe_ratio: Optional[float]   # 夏普比率
    sortino_ratio: Optional[float]  # 索提诺比率
    calmar_ratio: Optional[float]   # 卡玛比率
    win_rate: float                 # 胜率
    profit_factor: float            # 盈亏比
    trade_count: int                # 交易次数
    avg_trade_return: float         # 平均每笔收益
    avg_holding_days: float         # 平均持仓天数
    avg_win: float                  # 平均盈利
    avg_loss: float                 # 平均亏损
    max_consecutive_wins: int       # 最大连续盈利次数
    max_consecutive_losses: int     # 最大连续亏损次数


class EquityPoint(BaseModel):
    """资金曲线点"""
    date: datetime
    total_assets: float             # 总资产
    cash: float                     # 现金
    position_value: float           # 持仓市值
    benchmark: Optional[float]      # 基准净值


class DrawdownPoint(BaseModel):
    """回撤点"""
    date: datetime
    drawdown: float                 # 回撤比例 (负值)
    peak: float                     # 峰值
    trough: float                   # 谷值


class TradeRecord(BaseModel):
    """交易记录"""
    id: int
    datetime: datetime
    symbol: str
    direction: str                  # buy/sell
    price: float
    size: int
    value: float
    commission: float
    pnl: Optional[float]            # 平仓盈亏
    return_pct: Optional[float]     # 收益率
    holding_days: Optional[int]     # 持仓天数
    cumulative_pnl: float           # 累计盈亏


class TradeSignal(BaseModel):
    """交易信号"""
    date: datetime
    type: str                       # buy/sell
    price: float
    size: int
    reason: Optional[str]           # 交易原因


class KlineData(BaseModel):
    """K线数据"""
    date: datetime
    open: float
    high: float
    low: float
    close: float
    volume: int
    change_pct: Optional[float]     # 涨跌幅


class IndicatorData(BaseModel):
    """指标数据"""
    name: str
    values: List[Optional[float]]


class MonthlyReturn(BaseModel):
    """月度收益"""
    year: int
    month: int
    return_pct: float


class OptimizationResult(BaseModel):
    """参数优化结果"""
    params: Dict[str, any]
    metrics: PerformanceMetrics
    rank: int
    is_best: bool
```

#### 2.1.2 API响应模型
```python
# backend/app/schemas/analytics.py (续)

class BacktestDetailResponse(BaseModel):
    """回测详情响应"""
    task_id: str
    strategy_name: str
    symbol: str
    start_date: datetime
    end_date: datetime
    metrics: PerformanceMetrics
    equity_curve: List[EquityPoint]
    drawdown_curve: List[DrawdownPoint]
    trades: List[TradeRecord]
    created_at: datetime


class KlineWithSignalsResponse(BaseModel):
    """K线与信号响应"""
    symbol: str
    klines: List[KlineData]
    signals: List[TradeSignal]
    indicators: Dict[str, List[Optional[float]]]


class OptimizationResponse(BaseModel):
    """参数优化响应"""
    task_id: str
    parameters: List[str]
    results: List[OptimizationResult]
    best: OptimizationResult


class MonthlyReturnsResponse(BaseModel):
    """月度收益响应"""
    returns: List[MonthlyReturn]
    years: List[int]
    summary: Dict[str, float]  # 年度汇总
```

### 2.2 API路由设计

```python
# backend/app/api/analytics.py

from fastapi import APIRouter, Depends, HTTPException
from typing import Optional

from app.schemas.analytics import (
    BacktestDetailResponse,
    KlineWithSignalsResponse,
    OptimizationResponse,
    MonthlyReturnsResponse,
)
from app.services.analytics_service import AnalyticsService
from app.api.deps import get_current_user

router = APIRouter()


@router.get("/{task_id}/detail", response_model=BacktestDetailResponse)
async def get_backtest_detail(
    task_id: str,
    current_user=Depends(get_current_user),
    service: AnalyticsService = Depends(),
):
    """
    获取回测详细结果
    
    包含绩效指标、资金曲线、回撤曲线、交易记录等
    """
    result = await service.get_backtest_detail(task_id, current_user.id)
    if not result:
        raise HTTPException(status_code=404, detail="回测任务不存在")
    return result


@router.get("/{task_id}/kline", response_model=KlineWithSignalsResponse)
async def get_kline_with_signals(
    task_id: str,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    current_user=Depends(get_current_user),
    service: AnalyticsService = Depends(),
):
    """
    获取K线数据及交易信号
    
    用于绘制带买卖点标记的K线图
    """
    return await service.get_kline_with_signals(
        task_id, current_user.id, start_date, end_date
    )


@router.get("/{task_id}/optimization", response_model=OptimizationResponse)
async def get_optimization_results(
    task_id: str,
    sort_by: str = "sharpe_ratio",
    order: str = "desc",
    limit: int = 50,
    current_user=Depends(get_current_user),
    service: AnalyticsService = Depends(),
):
    """
    获取参数优化结果
    
    支持按不同指标排序
    """
    return await service.get_optimization_results(
        task_id, current_user.id, sort_by, order, limit
    )


@router.get("/{task_id}/monthly-returns", response_model=MonthlyReturnsResponse)
async def get_monthly_returns(
    task_id: str,
    current_user=Depends(get_current_user),
    service: AnalyticsService = Depends(),
):
    """
    获取月度收益数据
    
    用于绘制收益热力图
    """
    return await service.get_monthly_returns(task_id, current_user.id)


@router.get("/{task_id}/export")
async def export_backtest_results(
    task_id: str,
    format: str = "csv",  # csv, excel, json
    current_user=Depends(get_current_user),
    service: AnalyticsService = Depends(),
):
    """
    导出回测结果
    """
    return await service.export_results(task_id, current_user.id, format)
```

### 2.3 分析服务实现

```python
# backend/app/services/analytics_service.py

from typing import List, Dict, Optional
from datetime import datetime
import numpy as np
import pandas as pd

from app.schemas.analytics import *
from app.db.repositories import BacktestRepository


class AnalyticsService:
    """回测分析服务"""
    
    def __init__(self, repo: BacktestRepository):
        self.repo = repo
    
    async def get_backtest_detail(
        self, task_id: str, user_id: str
    ) -> BacktestDetailResponse:
        """获取回测详情"""
        task = await self.repo.get_task(task_id, user_id)
        if not task:
            return None
        
        result = await self.repo.get_result(task_id)
        
        # 计算绩效指标
        metrics = self._calculate_metrics(result)
        
        # 生成资金曲线
        equity_curve = self._generate_equity_curve(result)
        
        # 生成回撤曲线
        drawdown_curve = self._generate_drawdown_curve(equity_curve)
        
        # 获取交易记录
        trades = self._parse_trades(result)
        
        return BacktestDetailResponse(
            task_id=task_id,
            strategy_name=task.strategy_name,
            symbol=task.symbol,
            start_date=task.start_date,
            end_date=task.end_date,
            metrics=metrics,
            equity_curve=equity_curve,
            drawdown_curve=drawdown_curve,
            trades=trades,
            created_at=task.created_at,
        )
    
    def _calculate_metrics(self, result) -> PerformanceMetrics:
        """计算绩效指标"""
        # 从Backtrader分析器结果中提取数据
        trades = result.get('trades', [])
        equity = result.get('equity', [])
        
        initial = equity[0] if equity else 0
        final = equity[-1] if equity else 0
        
        # 计算收益率
        total_return = (final - initial) / initial if initial else 0
        
        # 计算年化收益
        days = len(equity)
        annualized = (1 + total_return) ** (252 / days) - 1 if days > 0 else 0
        
        # 计算最大回撤
        max_dd, max_dd_duration = self._calculate_max_drawdown(equity)
        
        # 计算夏普比率
        returns = np.diff(equity) / equity[:-1] if len(equity) > 1 else []
        sharpe = self._calculate_sharpe(returns)
        
        # 计算胜率和盈亏比
        wins = [t for t in trades if t.get('pnl', 0) > 0]
        losses = [t for t in trades if t.get('pnl', 0) < 0]
        
        win_rate = len(wins) / len(trades) if trades else 0
        avg_win = np.mean([t['pnl'] for t in wins]) if wins else 0
        avg_loss = abs(np.mean([t['pnl'] for t in losses])) if losses else 0
        profit_factor = avg_win / avg_loss if avg_loss else 0
        
        return PerformanceMetrics(
            initial_capital=initial,
            final_assets=final,
            total_return=total_return,
            annualized_return=annualized,
            max_drawdown=max_dd,
            max_drawdown_duration=max_dd_duration,
            sharpe_ratio=sharpe,
            sortino_ratio=None,  # TODO
            calmar_ratio=annualized / abs(max_dd) if max_dd else None,
            win_rate=win_rate,
            profit_factor=profit_factor,
            trade_count=len(trades),
            avg_trade_return=total_return / len(trades) if trades else 0,
            avg_holding_days=np.mean([t.get('holding_days', 0) for t in trades]) if trades else 0,
            avg_win=avg_win,
            avg_loss=avg_loss,
            max_consecutive_wins=self._max_consecutive(trades, True),
            max_consecutive_losses=self._max_consecutive(trades, False),
        )
    
    def _calculate_max_drawdown(self, equity: List[float]) -> tuple:
        """计算最大回撤"""
        if not equity:
            return 0, 0
        
        peak = equity[0]
        max_dd = 0
        max_dd_duration = 0
        current_duration = 0
        
        for value in equity:
            if value > peak:
                peak = value
                current_duration = 0
            else:
                dd = (peak - value) / peak
                current_duration += 1
                if dd > max_dd:
                    max_dd = dd
                    max_dd_duration = current_duration
        
        return -max_dd, max_dd_duration
    
    def _calculate_sharpe(self, returns: List[float], rf: float = 0) -> float:
        """计算夏普比率"""
        if len(returns) < 2:
            return None
        
        excess_returns = np.array(returns) - rf / 252
        return np.sqrt(252) * np.mean(excess_returns) / np.std(excess_returns)
    
    def _max_consecutive(self, trades: List[dict], win: bool) -> int:
        """计算最大连续盈利/亏损次数"""
        max_count = 0
        current = 0
        
        for t in trades:
            is_win = t.get('pnl', 0) > 0
            if is_win == win:
                current += 1
                max_count = max(max_count, current)
            else:
                current = 0
        
        return max_count
```

### 2.4 Backtrader 分析器增强

```python
# backend/app/services/backtest_analyzers.py

import backtrader as bt
from collections import OrderedDict


class DetailedTradeAnalyzer(bt.Analyzer):
    """详细交易分析器 - 记录每笔交易的详细信息"""
    
    def __init__(self):
        self.trades = []
        self.current_trade = None
    
    def notify_trade(self, trade):
        if trade.isclosed:
            self.trades.append({
                'ref': trade.ref,
                'datetime': self.datas[0].datetime.datetime(0),
                'symbol': trade.data._name,
                'size': trade.size,
                'price': trade.price,
                'value': trade.value,
                'commission': trade.commission,
                'pnl': trade.pnl,
                'pnlcomm': trade.pnlcomm,
                'barlen': trade.barlen,
            })
    
    def get_analysis(self):
        return {'trades': self.trades}


class EquityCurveAnalyzer(bt.Analyzer):
    """资金曲线分析器 - 记录每日资金变化"""
    
    def __init__(self):
        self.equity_curve = []
    
    def next(self):
        self.equity_curve.append({
            'datetime': self.datas[0].datetime.datetime(0),
            'total': self.strategy.broker.getvalue(),
            'cash': self.strategy.broker.getcash(),
            'position': self.strategy.broker.getvalue() - self.strategy.broker.getcash(),
        })
    
    def get_analysis(self):
        return {'equity_curve': self.equity_curve}


class TradeSignalAnalyzer(bt.Analyzer):
    """交易信号分析器 - 记录买卖信号"""
    
    def __init__(self):
        self.signals = []
    
    def notify_order(self, order):
        if order.status == order.Completed:
            signal_type = 'buy' if order.isbuy() else 'sell'
            self.signals.append({
                'datetime': self.datas[0].datetime.datetime(0),
                'type': signal_type,
                'price': order.executed.price,
                'size': order.executed.size,
            })
    
    def get_analysis(self):
        return {'signals': self.signals}


class MonthlyReturnsAnalyzer(bt.Analyzer):
    """月度收益分析器"""
    
    def __init__(self):
        self.monthly_returns = {}
        self.last_value = None
        self.last_month = None
    
    def next(self):
        dt = self.datas[0].datetime.datetime(0)
        month_key = (dt.year, dt.month)
        current_value = self.strategy.broker.getvalue()
        
        if self.last_month != month_key:
            if self.last_value and self.last_month:
                ret = (current_value - self.last_value) / self.last_value
                self.monthly_returns[self.last_month] = ret
            self.last_value = current_value
            self.last_month = month_key
    
    def stop(self):
        # 记录最后一个月的收益
        if self.last_value and self.last_month:
            current_value = self.strategy.broker.getvalue()
            ret = (current_value - self.last_value) / self.last_value
            self.monthly_returns[self.last_month] = ret
    
    def get_analysis(self):
        return {'monthly_returns': self.monthly_returns}
```

---

## 3. 前端设计

### 3.1 组件架构

```
src/components/charts/
├── common/
│   ├── ChartContainer.vue      # 图表容器（加载状态、错误处理）
│   ├── MetricCard.vue          # 指标卡片
│   └── ChartToolbar.vue        # 图表工具栏（缩放、导出等）
├── performance/
│   ├── PerformancePanel.vue    # 绩效指标面板
│   └── MetricGroup.vue         # 指标分组
├── kline/
│   ├── TradeSignalChart.vue    # 交易信号K线图
│   └── kline-options.ts        # ECharts K线配置
├── equity/
│   ├── EquityCurveChart.vue    # 资金曲线图
│   └── DrawdownChart.vue       # 回撤曲线图
├── analysis/
│   ├── ReturnHeatmap.vue       # 收益热力图
│   ├── ReturnDistribution.vue  # 收益分布图
│   └── HoldingPieChart.vue     # 持仓时间分布
├── optimization/
│   ├── OptimizationTable.vue   # 参数优化表格
│   └── OptimizationChart.vue   # 参数优化图表
└── trade/
    └── TradeRecordsTable.vue   # 交易记录表格
```

### 3.2 核心组件实现

#### 3.2.1 PerformancePanel.vue
```vue
<template>
  <div class="performance-panel">
    <h3 class="text-lg font-semibold mb-4">绩效概览</h3>
    
    <!-- 主要指标 -->
    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
      <MetricCard
        title="初始资金"
        :value="metrics.initial_capital"
        format="currency"
        icon="Wallet"
      />
      <MetricCard
        title="最终资产"
        :value="metrics.final_assets"
        :change="metrics.total_return"
        format="currency"
        icon="TrendingUp"
      />
      <MetricCard
        title="总收益率"
        :value="metrics.total_return"
        format="percent"
        :color="metrics.total_return >= 0 ? 'success' : 'danger'"
        icon="Percent"
      />
      <MetricCard
        title="年化收益"
        :value="metrics.annualized_return"
        format="percent"
        :color="metrics.annualized_return >= 0 ? 'success' : 'danger'"
        icon="Calendar"
      />
    </div>
    
    <!-- 风险指标 -->
    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
      <MetricCard
        title="最大回撤"
        :value="metrics.max_drawdown"
        format="percent"
        color="danger"
        icon="TrendingDown"
      />
      <MetricCard
        title="夏普比率"
        :value="metrics.sharpe_ratio"
        format="number"
        :precision="2"
        icon="Activity"
      />
      <MetricCard
        title="胜率"
        :value="metrics.win_rate"
        format="percent"
        icon="Target"
      />
      <MetricCard
        title="盈亏比"
        :value="metrics.profit_factor"
        format="number"
        :precision="2"
        icon="Scale"
      />
    </div>
    
    <!-- 交易统计 -->
    <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
      <MetricCard
        title="交易次数"
        :value="metrics.trade_count"
        format="number"
        icon="Repeat"
      />
      <MetricCard
        title="平均持仓"
        :value="metrics.avg_holding_days"
        format="days"
        icon="Clock"
      />
      <MetricCard
        title="最大连赢"
        :value="metrics.max_consecutive_wins"
        format="number"
        color="success"
        icon="Award"
      />
      <MetricCard
        title="最大连亏"
        :value="metrics.max_consecutive_losses"
        format="number"
        color="danger"
        icon="AlertTriangle"
      />
    </div>
  </div>
</template>

<script setup lang="ts">
import { PropType } from 'vue'
import MetricCard from './MetricCard.vue'
import type { PerformanceMetrics } from '@/types/analytics'

defineProps({
  metrics: {
    type: Object as PropType<PerformanceMetrics>,
    required: true
  }
})
</script>
```

#### 3.2.2 TradeSignalChart.vue
```vue
<template>
  <ChartContainer :loading="loading" :error="error">
    <div ref="chartRef" class="w-full" :style="{ height: height + 'px' }"></div>
    
    <template #toolbar>
      <ChartToolbar
        :periods="periods"
        :selected-period="selectedPeriod"
        @period-change="handlePeriodChange"
        @export="handleExport"
      />
    </template>
  </ChartContainer>
</template>

<script setup lang="ts">
import { ref, onMounted, watch, computed } from 'vue'
import * as echarts from 'echarts'
import ChartContainer from '../common/ChartContainer.vue'
import ChartToolbar from '../common/ChartToolbar.vue'
import { buildKlineOptions } from './kline-options'
import type { KlineData, TradeSignal } from '@/types/analytics'

const props = defineProps<{
  klines: KlineData[]
  signals: TradeSignal[]
  indicators?: Record<string, number[]>
  height?: number
}>()

const chartRef = ref<HTMLElement>()
let chartInstance: echarts.ECharts | null = null

const periods = [
  { label: '1月', value: '1m' },
  { label: '3月', value: '3m' },
  { label: '6月', value: '6m' },
  { label: '1年', value: '1y' },
  { label: '全部', value: 'all' },
]
const selectedPeriod = ref('all')

onMounted(() => {
  if (chartRef.value) {
    chartInstance = echarts.init(chartRef.value)
    renderChart()
  }
})

watch(() => [props.klines, props.signals], () => {
  renderChart()
}, { deep: true })

function renderChart() {
  if (!chartInstance || !props.klines.length) return
  
  const options = buildKlineOptions({
    klines: props.klines,
    signals: props.signals,
    indicators: props.indicators,
  })
  
  chartInstance.setOption(options)
}

function handlePeriodChange(period: string) {
  selectedPeriod.value = period
  // 根据时间周期过滤数据
}

function handleExport() {
  if (chartInstance) {
    const url = chartInstance.getDataURL({
      type: 'png',
      pixelRatio: 2,
      backgroundColor: '#fff'
    })
    const link = document.createElement('a')
    link.href = url
    link.download = 'kline-chart.png'
    link.click()
  }
}
</script>
```

#### 3.2.3 kline-options.ts
```typescript
// src/components/charts/kline/kline-options.ts

import type { EChartsOption } from 'echarts'
import type { KlineData, TradeSignal } from '@/types/analytics'

interface KlineOptionsParams {
  klines: KlineData[]
  signals: TradeSignal[]
  indicators?: Record<string, number[]>
}

export function buildKlineOptions(params: KlineOptionsParams): EChartsOption {
  const { klines, signals, indicators } = params
  
  // 准备数据
  const dates = klines.map(k => k.date)
  const ohlc = klines.map(k => [k.open, k.close, k.low, k.high])
  const volumes = klines.map((k, i) => {
    const isUp = k.close >= k.open
    return [i, k.volume, isUp ? 1 : -1]
  })
  
  // 买卖点标记
  const buyPoints = signals
    .filter(s => s.type === 'buy')
    .map(s => ({
      coord: [s.date, s.price],
      value: s.price,
      itemStyle: { color: '#ec0000' }
    }))
  
  const sellPoints = signals
    .filter(s => s.type === 'sell')
    .map(s => ({
      coord: [s.date, s.price],
      value: s.price,
      itemStyle: { color: '#00da3c' }
    }))
  
  return {
    animation: false,
    legend: {
      bottom: 10,
      left: 'center',
      data: ['日K', 'MA5', 'MA10', 'MA20', 'MA60']
    },
    tooltip: {
      trigger: 'axis',
      axisPointer: {
        type: 'cross'
      },
      backgroundColor: 'rgba(245, 245, 245, 0.8)',
      borderWidth: 1,
      borderColor: '#ccc',
      padding: 10,
      textStyle: {
        color: '#000'
      }
    },
    axisPointer: {
      link: [{ xAxisIndex: 'all' }],
      label: {
        backgroundColor: '#777'
      }
    },
    visualMap: {
      show: false,
      seriesIndex: 5,
      dimension: 2,
      pieces: [
        { value: 1, color: '#ec0000' },
        { value: -1, color: '#00da3c' }
      ]
    },
    grid: [
      {
        left: '10%',
        right: '8%',
        height: '50%'
      },
      {
        left: '10%',
        right: '8%',
        top: '63%',
        height: '16%'
      }
    ],
    xAxis: [
      {
        type: 'category',
        data: dates,
        boundaryGap: false,
        axisLine: { onZero: false },
        splitLine: { show: false },
        min: 'dataMin',
        max: 'dataMax',
        axisPointer: {
          z: 100
        }
      },
      {
        type: 'category',
        gridIndex: 1,
        data: dates,
        boundaryGap: false,
        axisLine: { onZero: false },
        axisTick: { show: false },
        splitLine: { show: false },
        axisLabel: { show: false },
        min: 'dataMin',
        max: 'dataMax'
      }
    ],
    yAxis: [
      {
        scale: true,
        splitArea: {
          show: true
        }
      },
      {
        scale: true,
        gridIndex: 1,
        splitNumber: 2,
        axisLabel: { show: false },
        axisLine: { show: false },
        axisTick: { show: false },
        splitLine: { show: false }
      }
    ],
    dataZoom: [
      {
        type: 'inside',
        xAxisIndex: [0, 1],
        start: 80,
        end: 100
      },
      {
        show: true,
        xAxisIndex: [0, 1],
        type: 'slider',
        top: '85%',
        start: 80,
        end: 100
      }
    ],
    series: [
      {
        name: '日K',
        type: 'candlestick',
        data: ohlc,
        itemStyle: {
          color: '#ec0000',
          color0: '#00da3c',
          borderColor: '#ec0000',
          borderColor0: '#00da3c'
        },
        markPoint: {
          label: {
            formatter: (param: any) => Math.round(param.value)
          },
          data: [
            ...buyPoints.map(p => ({
              ...p,
              symbol: 'triangle',
              symbolSize: 20,
              symbolRotate: 0
            })),
            ...sellPoints.map(p => ({
              ...p,
              symbol: 'triangle',
              symbolSize: 20,
              symbolRotate: 180
            }))
          ]
        }
      },
      // MA线
      ...(indicators?.ma5 ? [{
        name: 'MA5',
        type: 'line',
        data: indicators.ma5,
        smooth: true,
        lineStyle: { opacity: 0.5, width: 2 },
        showSymbol: false
      }] : []),
      ...(indicators?.ma10 ? [{
        name: 'MA10',
        type: 'line',
        data: indicators.ma10,
        smooth: true,
        lineStyle: { opacity: 0.5, width: 2 },
        showSymbol: false
      }] : []),
      ...(indicators?.ma20 ? [{
        name: 'MA20',
        type: 'line',
        data: indicators.ma20,
        smooth: true,
        lineStyle: { opacity: 0.5, width: 2 },
        showSymbol: false
      }] : []),
      // 成交量
      {
        name: 'Volume',
        type: 'bar',
        xAxisIndex: 1,
        yAxisIndex: 1,
        data: volumes
      }
    ]
  }
}
```

#### 3.2.4 ReturnHeatmap.vue
```vue
<template>
  <div class="return-heatmap">
    <h4 class="text-md font-medium mb-4">月度收益热力图</h4>
    <div ref="chartRef" class="w-full h-64"></div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, watch } from 'vue'
import * as echarts from 'echarts'
import type { MonthlyReturn } from '@/types/analytics'

const props = defineProps<{
  returns: MonthlyReturn[]
  years: number[]
}>()

const chartRef = ref<HTMLElement>()
let chartInstance: echarts.ECharts | null = null

const months = ['1月', '2月', '3月', '4月', '5月', '6月', 
                '7月', '8月', '9月', '10月', '11月', '12月']

onMounted(() => {
  if (chartRef.value) {
    chartInstance = echarts.init(chartRef.value)
    renderChart()
  }
})

watch(() => props.returns, () => {
  renderChart()
}, { deep: true })

function renderChart() {
  if (!chartInstance || !props.returns.length) return
  
  // 转换数据为热力图格式 [monthIndex, yearIndex, value]
  const data = props.returns.map(r => {
    const yearIndex = props.years.indexOf(r.year)
    return [r.month - 1, yearIndex, r.return_pct * 100]
  })
  
  const max = Math.max(...data.map(d => Math.abs(d[2] as number)))
  
  chartInstance.setOption({
    tooltip: {
      position: 'top',
      formatter: (params: any) => {
        const year = props.years[params.data[1]]
        const month = months[params.data[0]]
        const value = params.data[2].toFixed(2)
        return `${year}年${month}: ${value}%`
      }
    },
    grid: {
      height: '70%',
      top: '10%'
    },
    xAxis: {
      type: 'category',
      data: months,
      splitArea: { show: true }
    },
    yAxis: {
      type: 'category',
      data: props.years.map(String),
      splitArea: { show: true }
    },
    visualMap: {
      min: -max,
      max: max,
      calculable: true,
      orient: 'horizontal',
      left: 'center',
      bottom: '5%',
      inRange: {
        color: ['#00da3c', '#ffffff', '#ec0000']
      }
    },
    series: [{
      type: 'heatmap',
      data: data,
      label: {
        show: true,
        formatter: (params: any) => params.data[2].toFixed(1) + '%'
      },
      emphasis: {
        itemStyle: {
          shadowBlur: 10,
          shadowColor: 'rgba(0, 0, 0, 0.5)'
        }
      }
    }]
  })
}
</script>
```

### 3.3 页面组件

#### 3.3.1 BacktestResultPage.vue
```vue
<template>
  <div class="backtest-result-page p-6">
    <!-- 顶部标题和操作 -->
    <div class="flex justify-between items-center mb-6">
      <div>
        <h2 class="text-2xl font-bold">回测结果详情</h2>
        <p class="text-gray-500 mt-1">
          {{ result?.strategy_name }} | {{ result?.symbol }} | 
          {{ formatDate(result?.start_date) }} - {{ formatDate(result?.end_date) }}
        </p>
      </div>
      <div class="flex gap-2">
        <el-button @click="handleExport('csv')">
          <el-icon><Download /></el-icon>导出CSV
        </el-button>
        <el-button type="primary" @click="handleRerun">
          <el-icon><RefreshRight /></el-icon>重新回测
        </el-button>
      </div>
    </div>
    
    <!-- 绩效指标面板 -->
    <el-card class="mb-6">
      <PerformancePanel :metrics="result?.metrics" />
    </el-card>
    
    <!-- 图表区域 -->
    <el-tabs v-model="activeTab" class="mb-6">
      <el-tab-pane label="K线图" name="kline">
        <el-card>
          <TradeSignalChart
            :klines="klineData?.klines"
            :signals="klineData?.signals"
            :indicators="klineData?.indicators"
            :height="600"
          />
        </el-card>
      </el-tab-pane>
      
      <el-tab-pane label="资金曲线" name="equity">
        <el-card>
          <EquityCurveChart
            :equity-curve="result?.equity_curve"
            :height="400"
          />
          <DrawdownChart
            :drawdown-curve="result?.drawdown_curve"
            :height="200"
            class="mt-4"
          />
        </el-card>
      </el-tab-pane>
      
      <el-tab-pane label="收益分析" name="analysis">
        <div class="grid grid-cols-2 gap-4">
          <el-card>
            <ReturnHeatmap
              :returns="monthlyReturns?.returns"
              :years="monthlyReturns?.years"
            />
          </el-card>
          <el-card>
            <ReturnDistribution :trades="result?.trades" />
          </el-card>
        </div>
      </el-tab-pane>
      
      <el-tab-pane label="交易记录" name="trades">
        <el-card>
          <TradeRecordsTable :trades="result?.trades" />
        </el-card>
      </el-tab-pane>
      
      <el-tab-pane label="参数优化" name="optimization" v-if="hasOptimization">
        <el-card>
          <OptimizationTable :results="optimizationResults" />
          <OptimizationChart :results="optimizationResults" class="mt-4" />
        </el-card>
      </el-tab-pane>
    </el-tabs>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, computed } from 'vue'
import { useRoute } from 'vue-router'
import { analyticsApi } from '@/api/analytics'
import PerformancePanel from '@/components/charts/performance/PerformancePanel.vue'
import TradeSignalChart from '@/components/charts/kline/TradeSignalChart.vue'
import EquityCurveChart from '@/components/charts/equity/EquityCurveChart.vue'
import DrawdownChart from '@/components/charts/equity/DrawdownChart.vue'
import ReturnHeatmap from '@/components/charts/analysis/ReturnHeatmap.vue'
import ReturnDistribution from '@/components/charts/analysis/ReturnDistribution.vue'
import TradeRecordsTable from '@/components/charts/trade/TradeRecordsTable.vue'
import OptimizationTable from '@/components/charts/optimization/OptimizationTable.vue'
import OptimizationChart from '@/components/charts/optimization/OptimizationChart.vue'

const route = useRoute()
const taskId = computed(() => route.params.id as string)

const result = ref(null)
const klineData = ref(null)
const monthlyReturns = ref(null)
const optimizationResults = ref(null)
const activeTab = ref('kline')

const hasOptimization = computed(() => 
  optimizationResults.value?.results?.length > 0
)

onMounted(async () => {
  await loadData()
})

async function loadData() {
  const [detail, kline, returns] = await Promise.all([
    analyticsApi.getBacktestDetail(taskId.value),
    analyticsApi.getKlineWithSignals(taskId.value),
    analyticsApi.getMonthlyReturns(taskId.value),
  ])
  
  result.value = detail
  klineData.value = kline
  monthlyReturns.value = returns
  
  // 尝试加载参数优化结果
  try {
    optimizationResults.value = await analyticsApi.getOptimizationResults(taskId.value)
  } catch {
    // 没有优化结果
  }
}

function formatDate(date: string) {
  return date ? new Date(date).toLocaleDateString() : ''
}

function handleExport(format: string) {
  analyticsApi.exportResults(taskId.value, format)
}

function handleRerun() {
  // 跳转到回测页面，预填参数
}
</script>
```

---

## 4. 数据流设计

### 4.1 回测结果数据流
```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  Backtrader │ ──▶ │   Analyzers │ ──▶ │  Result DB  │
│   Engine    │     │             │     │             │
└─────────────┘     └─────────────┘     └─────────────┘
                                              │
                                              ▼
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│   Frontend  │ ◀── │  Analytics  │ ◀── │  Analytics  │
│  Components │     │     API     │     │   Service   │
└─────────────┘     └─────────────┘     └─────────────┘
```

### 4.2 状态管理 (Pinia Store)

```typescript
// stores/analytics.ts

import { defineStore } from 'pinia'
import { analyticsApi } from '@/api/analytics'

export const useAnalyticsStore = defineStore('analytics', {
  state: () => ({
    currentTaskId: null as string | null,
    detail: null,
    klineData: null,
    monthlyReturns: null,
    optimizationResults: null,
    loading: false,
    error: null as string | null,
  }),
  
  actions: {
    async loadBacktestResult(taskId: string) {
      this.loading = true
      this.error = null
      this.currentTaskId = taskId
      
      try {
        const [detail, kline, returns] = await Promise.all([
          analyticsApi.getBacktestDetail(taskId),
          analyticsApi.getKlineWithSignals(taskId),
          analyticsApi.getMonthlyReturns(taskId),
        ])
        
        this.detail = detail
        this.klineData = kline
        this.monthlyReturns = returns
      } catch (e) {
        this.error = e.message
      } finally {
        this.loading = false
      }
    },
    
    async loadOptimizationResults(taskId: string) {
      try {
        this.optimizationResults = await analyticsApi.getOptimizationResults(taskId)
      } catch {
        this.optimizationResults = null
      }
    },
    
    reset() {
      this.currentTaskId = null
      this.detail = null
      this.klineData = null
      this.monthlyReturns = null
      this.optimizationResults = null
    }
  }
})
```

---

## 5. 测试计划

### 5.1 单元测试

```python
# tests/unit/test_analytics_service.py

import pytest
from app.services.analytics_service import AnalyticsService

class TestAnalyticsService:
    
    def test_calculate_max_drawdown(self):
        service = AnalyticsService(None)
        equity = [100, 110, 105, 115, 100, 120]
        max_dd, duration = service._calculate_max_drawdown(equity)
        assert abs(max_dd - (-0.13)) < 0.01  # 115 -> 100
    
    def test_calculate_sharpe(self):
        service = AnalyticsService(None)
        returns = [0.01, 0.02, -0.01, 0.015, 0.005]
        sharpe = service._calculate_sharpe(returns)
        assert sharpe > 0
    
    def test_max_consecutive_wins(self):
        service = AnalyticsService(None)
        trades = [
            {'pnl': 100}, {'pnl': 50}, {'pnl': -30},
            {'pnl': 80}, {'pnl': 60}, {'pnl': 40}
        ]
        assert service._max_consecutive(trades, True) == 3
```

### 5.2 E2E测试

```python
# tests/e2e/test_backtest_result.py

class TestBacktestResultPage:
    
    def test_performance_panel_displays(self, authenticated_page):
        page = authenticated_page
        # 先运行一个回测
        # ...
        
        # 导航到结果页
        page.goto(f"{FRONTEND_URL}/backtest/{task_id}")
        page.wait_for_load_state("networkidle")
        
        # 验证绩效指标显示
        expect(page.locator("text=初始资金")).to_be_visible()
        expect(page.locator("text=最终资产")).to_be_visible()
        expect(page.locator("text=总收益率")).to_be_visible()
    
    def test_kline_chart_renders(self, authenticated_page):
        page = authenticated_page
        page.goto(f"{FRONTEND_URL}/backtest/{task_id}")
        
        # 等待图表渲染
        page.wait_for_selector(".echarts-container canvas")
        
        # 验证图表存在
        expect(page.locator(".echarts-container")).to_be_visible()
    
    def test_trade_records_table(self, authenticated_page):
        page = authenticated_page
        page.goto(f"{FRONTEND_URL}/backtest/{task_id}")
        
        # 切换到交易记录tab
        page.click("text=交易记录")
        
        # 验证表格显示
        expect(page.locator(".el-table")).to_be_visible()
```

---

## 6. 部署说明

### 6.1 依赖更新

```toml
# pyproject.toml 新增
[project.dependencies]
numpy = ">=1.24.0"
pandas = ">=2.0.0"
```

```json
// package.json 新增
{
  "dependencies": {
    "echarts": "^5.4.3"
  }
}
```

### 6.2 数据库迁移

无需数据库迁移，分析数据从已有的回测结果中计算得出。

---

## 7. 附录

### 7.1 ECharts 图表配置参考

参考 `stock-backtrader-web-app/internal/pkg/charts/stock.py` 中的 `draw_pro_kline` 函数实现。

### 7.2 Plotly 图表配置参考

参考 `stock-backtrader-web-app/core/contract/drawer.py` 中的 `Drawer` 类实现。
